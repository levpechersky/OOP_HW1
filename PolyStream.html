'From Squeak5.1 of 5 September 2016 [latest update: #16549] on 3 November 2017 at 3:57:25 pm'!Object subclass: #PolyStream	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!PolyStream commentStamp: 'LP 11/3/2017 13:23' prior: 0!PolyStream (aka PolyBlock in 2013)!!PolyStream methodsFor: 'algebra' stamp: 'LP 11/3/2017 15:28'!add: aPolyStream 	| blockBefore |	(aPolyStream isMemberOf: PolyStream)	ifFalse: [ self error: 'invalid input' ].		blockBefore := block.	block := [		| lhsDict rhsDict presentCoef |		lhsDict := blockBefore value.		rhsDict := aPolyStream block value.				rhsDict keysAndValuesDo: [ :exp  :coeff |		(lhsDict includesKey: exp)		ifTrue:			[ presentCoef := lhsDict at: exp. lhsDict at: exp put: presentCoef + coeff ]		ifFalse: 			[ lhsDict add: exp->coeff ].		].		lhsDict	].! !!PolyStream methodsFor: 'algebra' stamp: 'LP 11/3/2017 13:24'!addCoef: coef withExp: exp	| blockBefore |	((coef isInteger) and: [exp isInteger] and: [exp >= 0])	ifFalse: [ self error: 'invalid input' ].		blockBefore := block.	block := [		| dict presentCoef |		dict := blockBefore value.				(dict includesKey: exp)		ifTrue:			[ presentCoef := dict at: exp. 			dict at: exp put: presentCoef + coef ]		ifFalse: 			[ dict add: exp->coef ].		dict " add: and at:put: return k->v association, we need to return a dictionary"	].		! !!PolyStream methodsFor: 'algebra' stamp: 'LP 11/3/2017 13:02'!eval: anInteger	| polyDict sum |	(anInteger isInteger)	ifFalse: [ self error: 'invalid input' ].		polyDict := block value.	sum := 0.	polyDict keysAndValuesDo: [ :exp  :coeff |		sum := sum + (coeff * (anInteger raisedTo: exp))	]. 	^sum	! !!PolyStream methodsFor: 'algebra' stamp: 'LP 11/3/2017 13:47'!multiplyBy: anInteger	| blockBefore |	(anInteger isInteger)	ifFalse: [ self error: 'invalid input' ].	" TODO: handle anInteger = 0 "	blockBefore := block.	block := [		| dict |		dict := blockBefore value.		dict collect: [ :coeff |  anInteger * coeff ].			].! !!PolyStream methodsFor: 'initialize-release' stamp: 'LP 11/3/2017 12:37'!initialize	"Creates a new polynom as 0."	block := [ Dictionary new ].	^self! !!PolyStream methodsFor: 'properties' stamp: 'LP 11/2/2017 21:48'!block	^block! !!PolyStream methodsFor: 'as yet unclassified' stamp: 'LP 11/3/2017 14:04'!filter: aSet	| setCopy blockBefore |	setCopy := aSet deepCopy.		blockBefore := block.	block := [ 		| dict |		dict := blockBefore value.		setCopy do: [ :exp | dict removeKey: exp ifAbsent: []].		dict	].		! !!PolyStream methodsFor: 'as yet unclassified' stamp: 'LP 11/3/2017 14:49'!intersectionWith: aPolyStream withinRange: anInteger	| guesser currentX nextX |	((aPolyStream isMemberOf: PolyStream) and: [anInteger isInteger])	ifFalse: [ self error: 'invalid input' ].		nextX := [ :x |		(x <= 0)		ifTrue:  [ (x negated) + 1 ]		ifFalse: [ x negated ]	].	currentX := 0.	guesser := [		| res lhs rhs |		((currentX abs) > anInteger)		ifTrue: [self error: 'intersection is out of range' ].				lhs := self.		rhs := aPolyStream.				((lhs eval: currentX ) = (rhs eval: currentX))		ifTrue:  [ res := currentX ]		ifFalse: [ res := 'wait for it...'].						currentX := nextX value: currentX.				res " x-value of intersection or 'wait for it...' " 	].	^guesser	! !!PolyStream methodsFor: 'as yet unclassified' stamp: 'LP 11/3/2017 15:51'!substitute: anInteger	| blockBefore |	((anInteger isInteger) and: [anInteger ~= 0])	ifFalse: [ self error: 'invalid input' ].		blockBefore := block.	block := [		| dict newDict |		dict := blockBefore value.		newDict := Dictionary new.		dict keysAndValuesDo: [ :exp  :coeff |			newDict at: exp put: (coeff * (anInteger raisedTo: exp)).		]. 			newDict	].! !